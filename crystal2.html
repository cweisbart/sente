<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced WebGL Crystal (v8 - Touch+Mouse)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; }
        canvas { display: block; }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
          "three/": "https://cdn.jsdelivr.net/npm/three@0.158.0/"
        }
      }
    </script>

</head>
<body>
    
    <script type="module">

        // Imports
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- Variables ---
        
        let scene, camera, renderer, crystalGroup, composer;
        let autoRotationSpeed = 0.005;
        let currentRotationSpeed = autoRotationSpeed;
        let isDragging = false;
        let previousMouseX = 0; // Will be used for both mouse and touch
        let rotationTargetSpeed = autoRotationSpeed;
        let decelerationFactor = 0.98;

        const NUM_CONCENTRIC_SHAPES = 3;
        const BLOOM_STRENGTH = 1.5; 
        const BLOOM_THRESHOLD = 0;
        const BLOOM_RADIUS = 0;

        // --- Functions ---
        
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 6; // Camera zoomed out

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // Crystal Group
            crystalGroup = new THREE.Group();
            scene.add(crystalGroup);

            // Geometries and Materials
            const baseGeometry = new THREE.IcosahedronGeometry(1, 0);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 2, 
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const nodeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < NUM_CONCENTRIC_SHAPES; i++) {
                const scale = 1 + (i * 0.3); 
                const crystal = new THREE.Group();
                const edges = new THREE.EdgesGeometry(baseGeometry);
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                wireframe.scale.set(scale, scale, scale);
                crystal.add(wireframe);

                if (i === NUM_CONCENTRIC_SHAPES - 1) { 
                    const vertexPositions = baseGeometry.attributes.position.array;
                    const nodeRadius = 0.05 * scale;
                    const nodeGeometry = new THREE.SphereGeometry(nodeRadius, 8, 8); 

                    for (let j = 0; j < vertexPositions.length; j += 3) {
                        const x = vertexPositions[j];
                        const y = vertexPositions[j + 1];
                        const z = vertexPositions[j + 2];
                        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                        node.position.set(x * scale, y * scale, z * scale);
                        crystal.add(node);
                    }
                }
                crystalGroup.add(crystal);
            }

            // Bloom Effect Composer
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                BLOOM_STRENGTH,
                BLOOM_RADIUS,
                BLOOM_THRESHOLD
            );
            composer.addPass(bloomPass);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            // Mouse Events
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseleave', onMouseUp, false);
            
            // V V V NEW TOUCH EVENTS V V V
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); 
        }

        // --- Mouse Handlers ---

        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMouseX;
                currentRotationSpeed += deltaX * 0.0001;
                rotationTargetSpeed = currentRotationSpeed;
                previousMouseX = event.clientX;
            }
        }

        function onMouseUp() {
            isDragging = false;
            rotationTargetSpeed = autoRotationSpeed;
        }

        // --- V V V NEW TOUCH HANDLERS V V V ---
        
        function onTouchStart(event) {
            if (event.touches.length === 1) { // Only track the first finger
                isDragging = true;
                previousMouseX = event.touches[0].clientX;
            }
        }

        function onTouchMove(event) {
            if (isDragging && event.touches.length === 1) {
                // Prevent screen from scrolling
                event.preventDefault(); 
                
                const touchX = event.touches[0].clientX;
                const deltaX = touchX - previousMouseX;
                currentRotationSpeed += deltaX * 0.0001;
                rotationTargetSpeed = currentRotationSpeed;
                previousMouseX = touchX;
            }
        }

        function onTouchEnd() {
            isDragging = false;
            rotationTargetSpeed = autoRotationSpeed;
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (!isDragging) {
                currentRotationSpeed = currentRotationSpeed * decelerationFactor + rotationTargetSpeed * (1 - decelerationFactor);
                
                if (Math.abs(currentRotationSpeed - autoRotationSpeed) < 0.0001) {
                    currentRotationSpeed = autoRotationSpeed;
                }
            }
            
            crystalGroup.rotation.x += currentRotationSpeed;
            crystalGroup.rotation.y += currentRotationSpeed * 0.5;

            composer.render();
        }

        // --- Start ---
        init();
        animate();
    </script>
</body>
</html>